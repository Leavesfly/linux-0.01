# Linux 0.01 发布说明

**Linux 内核版本 0.01**  
*作者：林纳斯·托瓦兹 (Linus Torvalds)*  
*发布时间：1991年*

---

## 目录

0. [目录内容说明](#0-目录内容说明)
1. [项目简介](#1-项目简介)
2. [版权与许可](#2-版权与许可)
3. [内核技术概述](#3-内核技术概述)
4. [核心子系统](#4-核心子系统)
5. [内存管理](#5-内存管理)
6. [文件系统](#6-文件系统)
7. [致歉声明](#7-致歉声明)
8. [编译与运行](#8-编译与运行)
9. [现代编译指南](#9-现代编译指南)

---

## 0. 目录内容说明

本目录包含以下文件：
- `linux-0.01.tar.Z` - 内核源代码
- `bash.Z` - 压缩的 bash 二进制文件（用于测试）
- `update.Z` - 压缩的 update 二进制文件
- `RELNOTES-0.01` - 本发布说明文件

---

## 1. 项目简介

这是一个针对基于 Intel 80386（及更高版本）AT 机器的免费类 Minix 内核。源代码完全开放，已经在两台不同的机器上成功编译并运行。由于不同机器的硬件配置差异，目前没有提供预编译的二进制内核，用户需要自己编译。

### 硬件要求

要运行 Linux 0.01，您需要：
- **处理器**：Intel 80386 AT 兼容机
- **显示器**：VGA/EGA 显卡
- **存储**：AT 型硬盘控制器（IDE 接口兼容）
- **键盘**：芬兰键盘（可以使用美式键盘，但需要一些练习 😊）

> **注意**：芬兰键盘是硬编码的，因为我没有美式键盘无法轻易更改。详情请参考 `kernel/keyboard.s` 文件。如果有人愿意移植键盘映射，我将非常感激。这应该不会太难，因为它是表驱动的（虽然是汇编代码）。

### 版本说明

如版本号（0.01）所示，这并不是一个成熟的产品。目前仅支持部分 AT 硬件（硬盘、屏幕、键盘和串行线），并且一些系统调用尚未完全实现（特别是 mount/umount 甚至还没有实现）。详情请查看代码注释。

这个版本主要用于阅读 - 即如果您对系统当前的样子感兴趣。它可以编译并生成一个可工作的内核，虽然我会尽力帮助您在您的机器上运行它（请发邮件给我），但实际上并不提供正式支持。变更频繁，第一个"生产"版本可能与这个预 Alpha 版本差异很大。

虽然 Linux 是一个完整的内核，不使用 Minix 或其他来源的代码，但几乎没有编写任何支持例程。因此，您目前需要 Minix 来引导系统。可能可以使用免费的 Minix 演示盘制作文件系统并在没有 Minix 的情况下运行 Linux，但我不确定...

---

## 2. 版权与许可

本内核版权归 1991 年林纳斯·托瓦兹所有，但在满足以下条件的情况下，可以重新分发全部或部分内容：

- **源码自由**：必须提供完整的源代码（且免费），如果不随分发提供，至少要在请求时提供。
- **版权完整**：版权声明必须保持完整。（实际上，如果您只分发部分代码，可能需要添加版权声明，因为并非所有文件都有版权标记。）小的部分摘录可以在不考虑版权的情况下复制。
- **禁止收费**：您不得为此收费，即使是"处理"费用也不行。

如有任何问题，请发邮件至 "torvalds@kruuna.helsinki.fi"。

遗憾的是，仅有内核是不够的。要获得一个可工作的系统，您需要 shell、编译器、库等。这些是独立的部分，可能有更严格（或更宽松）的版权。与 Linux 一起使用的大多数工具都是 GNU 软件，受 GNU copyleft 保护。这些工具不在分发中 - 请向我（或 GNU）询问更多信息。

---

## 3. 内核技术概述

Linux 内核是在 Minix 环境下开发的，我最初的想法是让它与 Minix 二进制兼容。由于差异变得更大，这个想法被放弃了，但系统仍然在很大程度上类似于 Minix。一些关键特点包括：

### 充分利用 386 处理器能力
Minix 是在 8088 上编写的，后来移植到其他机器 - Linux 充分利用了 386 的优势（如果您有 386 这很好，但这使得移植非常困难）。

### 无消息传递
这是一种更传统的 Unix 方法。系统调用就是调用。这可能更快也可能不快，但这确实意味着我们可以省去消息的一些问题（消息队列等）。当然，我们也错过了一些好功能 😛

### 多线程文件系统
这是不使用消息的直接后果。这使得文件系统变得更复杂（复杂得多），但更好用。加上更好的调度器，这意味着您实际上可以同时运行多个进程，而不会遇到 Minix 引起的性能损失。

### 最小任务切换
这也是不使用消息的后果。我们只在真正想要切换任务时才进行任务切换 - 不像 Minix 无论您做什么都要进行任务切换。这意味着我们可以更容易地实现 387 支持（实际上这已经基本实现了）。

### 中断不隐藏
一些人（其中包括 Tanenbaum）认为中断是丑陋的，应该隐藏。在我看来不是这样。由于实际原因，中断必须主要由机器代码处理，这很遗憾，但它们是代码的一部分，就像其他一切一样。特别是设备驱动程序主要是中断例程 - 请参见 `kernel/hd.c` 等。

### 单一地址空间
内核/文件系统/内存管理之间没有区别，它们都链接到同一个代码堆中。这有好的一面也有坏的一面。代码不如 Minix 代码那样模块化，但另一方面某些事情更简单。内核的不同部分在源代码树的不同子目录下，但在运行时一切都在同一个数据/代码空间中发生。

实现 Linux 时的指导原则是：**快速让它工作**。我希望内核简单，但足够强大以运行大多数 Unix 软件。我对文件系统做不了太多 - 出于实际原因它需要与 Minix 兼容，而 Minix 文件系统本身就足够简单了。内核和内存管理可以简化：

- **统一任务结构**："真正的"Unix 在多个地方有任务信息，我希望所有东西都在一个地方。
- **简单内存管理算法**：使用 i386 的分页和分段能力。目前内存管理只是两个文件 - `memory.c` 和 `page.s`，只有几百行代码。

这些决定似乎效果很好 - 错误很容易发现，系统工作正常。

---

## 4. 核心子系统

### 内核核心 (kernel/)
所有处理任务的例程都在 "kernel" 子目录中。这些包括 'fork' 和 'exit' 等功能以及调度和次要系统调用如 'getpid' 等。这里还有大多数异常和陷阱的处理程序（不包括页错误，它们在 mm 中），以及所有底层设备驱动程序（get_hd_block、tty_write 等）。目前所有错误都导致退出并返回错误代码 11（分段错误），系统似乎相对稳定（"crashme" 还没有崩溃过）。

---

## 5. 内存管理

这是所有部分中最简单的，应该只需要很少的更改。它包含内核其余部分需要的一些功能的入口点，但主要是自己处理，在页错误发生时处理它们。实际上，内核的其余部分通常不主动分配页面，只是写入用户空间，让内存管理处理任何可能的"页面不存在"错误。

内存以两种完全不同的方式处理 - 通过分页和分段。首先将 386 虚拟内存空间（4GB）分为若干段（目前是 64 个 64MB 的段），第一个是内核内存段，完整的物理内存恒等映射到其中。所有内核函数都在这个区域内运行。

然后给每个任务分配一个段，供其随意使用。分页机制负责用适当的页面填充段，跟踪任何重复副本（在 'fork' 时创建），并在任何写入时制作副本。系统的其余部分不需要了解所有这些。

---

## 6. 文件系统

如前所述，Linux 文件系统与 Minix 中的相同。这使得从 Minix 交叉编译变得容易，并且意味着您可以从 Minix 挂载 Linux 分区（或者一旦我实现 mount 就可以反过来 😊）。不过这只是在逻辑层面 - 实际的例程非常不同。

> **注意！** Minix-1.6.16 似乎有一个新的文件系统，对我一直使用的 1.5.10 有轻微修改。Linux 不理解新系统。

主要区别在于 Minix 有单线程文件系统而 Linux 没有。实现单线程文件系统要容易得多，因为您不需要担心其他进程在您做其他事情时分配缓冲块等。这也意味着您失去了对 Unix 如此重要的一些多处理功能。

由于多线程，Linux 内核需要解决许多问题（死锁/竞争条件）。抑制竞争条件的一种方法是锁定您需要的所有东西，但由于这可能导致不必要的阻塞，我决定永远不锁定任何数据结构（除非实际读取或写入物理设备）。这有一个很好的特性，即不会发生死锁。

遗憾的是，它有一个不太好的特性，即几乎到处都可能发生竞争条件。这些通过双重检查分配等方式处理（请参见 `fs/buffer.c` 和 `fs/inode.c`）。不让内核在处于监督模式时调度任务（标准 Unix 做法），意味着所有内核/文件系统/内存管理操作都是原子的（不计算中断，我们在编写这些时很小心），如果您不调用 'sleep'，所以这是我们可以依靠的事情之一。

---

## 7. 致歉声明

这还不是"所有操作系统之母"，任何希望如此的人都必须等待第一个真正的发布版（1.0），即使那样您也可能不想从 Minix 更换。这是一个源代码发布，面向那些有兴趣看看 Linux 是什么样子的人，目前还没有真正得到支持。任何有问题或建议（甚至错误报告，如果您决定让它在您的系统上工作）的人都被鼓励给我发邮件。

---

## 8. 编译与运行

大多数硬件依赖性都必须编译到系统中，在文件 "`include/linux/config.h`" 中有许多定义，您必须更改以获得个性化的内核。您还必须在文件 `boot/boot.s` 中取消注释正确的 "equ"，告诉引导例程您的 A 软盘是什么类型的设备。之后简单的 "make" 应该生成文件 "Image"，您可以将其复制到软盘（我使用 `cp Image /dev/PS0` 用于 1.44Mb 软盘）。就是这样。

不过，没有任何程序可以运行，内核什么也做不了。您应该在找到这个的同一个地方找到 'update' 和 'bash' 的二进制文件，它们必须放在指定根设备上的 '/bin' 目录中（在 config.h 中指定）。Bash 必须以 '/bin/sh' 的名称找到，因为这是内核当前执行的。快乐的黑客时光。

---

## 9. 现代编译指南

### 环境要求

由于 Linux 0.01 是 1991 年的代码，在现代系统上编译需要特殊的环境配置：

#### 编译器要求
- **推荐**：GCC 4.8 或兼容版本
- **必需标志**：
  ```bash
  CFLAGS = -Wall -O -std=gnu89 -fstrength-reduce -fomit-frame-pointer \
           -fno-stack-protector -fno-builtin -g -m32
  ```

#### 关键编译选项说明
- **`-m32`**：强制生成 32 位代码（Linux 0.01 是纯 32 位内核）
- **`-fno-stack-protector`**：禁用现代 GCC 的栈保护，避免与低层汇编代码冲突
- **`-fno-builtin`**：禁用内建函数优化，使用内核自定义的库函数实现
- **`-std=gnu89`**：使用 GNU C89 标准确保语法兼容性

#### 32 位支持库
在 64 位系统上，您需要安装 32 位开发库：
```bash
# Ubuntu/Debian
sudo apt-get install gcc-multilib libc6-dev-i386

# CentOS/RHEL
sudo yum install glibc-devel.i686
```

### 内核配置

编辑 `include/linux/config.h` 配置您的系统：

#### 内存配置
```c
#define HIGH_MEMORY 0x800000    // 8MB (LINUS_HD)
// 或
#define HIGH_MEMORY 0x400000    // 4MB (LASU_HD)
```

#### 根设备配置
```c
#define ROOT_DEV 0x306          // /dev/hda6 (LINUS_HD)
// 或
#define ROOT_DEV 0x302          // /dev/hda2 (LASU_HD)
```

#### 硬盘参数
```c
#define HD_TYPE { 5,17,980,300,980,0 }  // CHS 参数
```

### 引导配置

编辑 `boot/boot.s`，取消注释您的软盘类型：
```assembly
sectors = 18        ; 1.44Mb 软盘
; sectors = 15      ; 1.2Mb 软盘
; sectors = 9       ; 720kb 软盘
```

### 编译步骤

1. **配置环境**：
   ```bash
   export CC=gcc-4.8
   export CFLAGS="-m32 -fno-stack-protector -fno-builtin"
   ```

2. **编译内核**：
   ```bash
   make clean
   make
   ```

3. **生成启动镜像**：
   ```bash
   # 生成的 Image 文件可以写入软盘
   dd if=Image of=/dev/fd0
   ```

### 现代虚拟化运行

由于现代硬件差异，推荐在虚拟机中运行：

#### QEMU 运行
```bash
qemu-system-i386 -fda Image -boot a -m 8M
```

#### VirtualBox 设置
- 创建新虚拟机（类型：Linux，版本：Other Linux）
- 内存：8MB
- 启用软盘驱动器，挂载 Image 文件
- 禁用硬件加速功能

### 故障排除

#### 常见编译错误
1. **栈保护错误**：确保使用 `-fno-stack-protector`
2. **32位链接错误**：安装 32 位开发库和 multilib 支持
3. **汇编语法错误**：使用兼容的 GCC 版本（4.8 推荐）

#### 运行时问题
1. **启动失败**：检查 `boot/boot.s` 中的软盘参数配置
2. **内存错误**：确认 `config.h` 中的内存设置与实际环境匹配
3. **硬盘无法识别**：验证 `HD_TYPE` 参数是否正确

---

## 联系信息

**林纳斯·托瓦兹**  
邮箱：torvalds@kruuna.helsinki.fi  
地址：Petersgatan 2 A 2  
      00140 Helsingfors 14  
      FINLAND

---

*这份文档翻译并扩展了原始的 Linux 0.01 README，增加了现代编译指南和详细的技术说明，旨在帮助现代开发者理解和运行这个历史性的操作系统内核。*

---

## 项目结构

```
linux-0.01/
├── boot/           # 引导加载程序
├── fs/             # 文件系统
├── include/        # 头文件
│   ├── asm/        # 汇编相关头文件
│   ├── linux/      # Linux 内核头文件
│   └── sys/        # 系统调用头文件
├── init/           # 内核初始化
├── kernel/         # 内核核心功能
├── lib/            # 库函数
├── mm/             # 内存管理
├── tools/          # 构建工具
└── Makefile        # 主构建文件
```

这个早期的 Linux 内核展示了操作系统设计的基本原理，虽然功能有限，但它为现代 Linux 系统奠定了坚实的基础。通过学习这份代码，您可以深入理解操作系统内核的工作原理。