# 超级块管理

<cite>
**本文档引用的文件**  
- [fs/super.c](file://fs/super.c)
- [include/linux/fs.h](file://include/linux/fs.h)
- [init/main.c](file://init/main.c)
</cite>

## 目录
1. [引言](#引言)
2. [超级块数据结构与静态分配](#超级块数据结构与静态分配)
3. [超级块查找与设备挂载](#超级块查找与设备挂载)
4. [位图操作与资源管理](#位图操作与资源管理)
5. [根文件系统挂载流程](#根文件系统挂载流程)
6. [只读标志与系统控制](#只读标志与系统控制)

## 引言
本文档系统性地分析 Linux 0.01 内核中超级块（super-block）的管理机制。超级块是文件系统的核心元数据结构，存储了文件系统的全局信息，如 inode 数量、数据块布局、位图位置等。本分析聚焦于 `fs/super.c` 模块中的核心逻辑，包括超级块的静态分配、查找算法、位图操作以及根文件系统的初始化挂载过程。

## 超级块数据结构与静态分配

`super_block` 结构体定义了超级块的内存布局，包含文件系统的静态信息（如 `s_ninodes`、`s_nzones`）和运行时状态（如 `s_dev`、`s_dirt`）。该结构体在 `include/linux/fs.h` 中声明，并通过 `extern` 关键字在全局作用域中声明。

关键的静态分配体现在 `super_block` 数组的定义上：
```c
struct super_block super_block[NR_SUPER];
```
该数组在内核启动时静态分配，其大小由 `NR_SUPER` 宏（定义为 8）决定。这意味着系统最多同时支持 8 个已挂载的文件系统实例。这种静态分配方式简化了内存管理，但限制了系统的可扩展性。

**Section sources**
- [include/linux/fs.h](file://include/linux/fs.h#L130-L150)
- [fs/super.c](file://fs/super.c#L10)

## 超级块查找与设备挂载

### 超级块查找算法
`get_super()` 函数提供了一个通过设备号查找对应超级块的接口。其实现采用简单的线性搜索算法：
```c
inline struct super_block * get_super(int dev)
{
	struct super_block * s;
	for(s = 0+super_block; s < NR_SUPER+super_block; s++)
		if (s->s_dev == dev)
			return s;
	return NULL;
}
```
该函数遍历 `super_block` 数组，比较每个条目的 `s_dev` 字段与传入的设备号。一旦找到匹配项，立即返回指向该超级块的指针；若遍历结束未找到，则返回 `NULL`。此算法时间复杂度为 O(N)，其中 N 为 `NR_SUPER`，在当前实现中为常数时间。

**Section sources**
- [include/linux/fs.h](file://include/linux/fs.h#L170-L178)

### 设备挂载流程
`do_mount()` 函数负责将一个设备挂载为文件系统。其核心逻辑如下：
1.  **查找空闲槽位**：遍历 `super_block` 数组，找到第一个 `s_dev` 为 0 的条目。
2.  **临时标记**：将该条目的 `s_dev` 设置为 -1，标记为“正在使用”，防止并发挂载。
3.  **读取超级块**：调用 `bread(dev, 1)` 从设备的第 1 块（块号从 1 开始）读取原始超级块数据。
4.  **魔数校验**：检查读取到的超级块的 `s_magic` 字段是否等于 `SUPER_MAGIC` (0x137F)。若不匹配，则认为设备上无有效文件系统，释放资源并返回 `NULL`。
5.  **初始化位图指针**：将 `s_imap` 和 `s_zmap` 数组的所有指针初始化为 `NULL`。
6.  **读取位图块**：根据 `s_imap_blocks` 和 `s_zmap_blocks` 字段，依次读取 inode 位图和数据块位图的各个块，并将 `buffer_head` 指针存入 `s_imap` 和 `s_zmap` 数组。
7.  **完整性校验**：检查实际读取的块数是否与超级块中记录的 `s_imap_blocks` 和 `s_zmap_blocks` 之和相符。若不符，则释放所有已读取的缓冲区，重置 `s_dev` 并返回 `NULL`。
8.  **最终初始化**：将 inode 位图和数据块位图的第一个比特位置 1（通常表示根目录 inode 和超级块本身已被占用），设置 `s_dev` 为实际设备号，并初始化其他运行时字段（如 `s_rd_only=0`）。
9.  **返回成功**：返回指向已初始化超级块的指针。

此流程确保了挂载操作的原子性和数据一致性。

**Section sources**
- [fs/super.c](file://fs/super.c#L12-L68)

## 位图操作与资源管理

### 位图操作宏
`fs/super.c` 中定义了 `set_bit` 宏，用于操作位图（bitmap）。该宏直接使用 x86 汇编指令 `bt` (bit test) 和 `setb` (set if below) 来测试并设置指定位。
```c
#define set_bit(bitnr,addr) ({ \
register int __res __asm__("ax"); \
__asm__("bt %2,%3;setb %%al":"=a" (__res):"a" (0),"r" (bitnr),"m" (*(addr))); \
__res; })
```
- `bt bitnr, addr`：测试 `addr` 指向的内存中第 `bitnr` 位的值，并将其存入标志寄存器的 Carry Flag (CF)。
- `setb %al`：如果 CF 为 1（即该位为 1），则将寄存器 `%al`（`__res` 的低 8 位）置 1；否则置 0。
该宏的返回值是该位的原始值（1 表示已设置，0 表示未设置）。`clear_bit` 函数（未在 `super.c` 中定义，但由 `bitmap.c` 提供）则用于清除位图中的位。

### 位图在挂载中的应用
在 `mount_root()` 函数中，`set_bit` 被用来统计空闲的 inode 和数据块数量：
```c
while (-- i >= 0)
	if (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))
		free++;
```
这段代码遍历所有数据块（`i` 从 `p->s_nzones` 递减到 0）：
- `i >> 13`：确定该块号对应的位图块索引（因为一个块 1024 字节 = 8192 比特，所以每 8192 个块需要一个位图块）。
- `i & 8191`：确定该块号在对应位图块中的比特偏移量。
- `set_bit(...)`：尝试设置该比特位。如果返回 0，说明该位原本是 0（即该数据块空闲），于是 `free` 计数器加 1。
此操作巧妙地利用了 `set_bit` 的副作用（返回原值）来统计空闲资源，而不会真正改变位图状态（因为后续没有写回操作）。

**Section sources**
- [fs/super.c](file://fs/super.c#L5-L9)
- [fs/super.c](file://fs/super.c#L84-L85)
- [fs/super.c](file://fs/super.c#L92-L93)

## 根文件系统挂载流程

`mount_root()` 函数在系统初始化阶段扮演着至关重要的角色，它负责挂载根文件系统（`ROOT_DEV`），为整个用户空间的启动奠定基础。

其执行流程如下：
1.  **内核自检**：检查 `struct d_inode` 的大小是否为 32 字节，确保与磁盘上的 inode 格式兼容。
2.  **文件表初始化**：将 `file_table` 数组中所有条目的引用计数 `f_count` 重置为 0。
3.  **超级块表清零**：将 `super_block` 数组中所有条目的 `s_dev` 字段清零，表示所有槽位空闲。
4.  **挂载根设备**：调用 `do_mount(ROOT_DEV)` 尝试挂载根设备。若失败，则调用 `panic` 终止系统。
5.  **读取根目录 inode**：调用 `iget(ROOT_DEV, 1)` 从根设备读取 inode 编号为 1 的 inode（即根目录）。若失败，同样 `panic`。
6.  **建立关联**：将超级块的 `s_isup`（指向根目录 inode）和 `s_imount`（指向被挂载的 inode）都指向刚读取的根目录 inode。
7.  **设置进程根和工作目录**：将当前进程（`current`）的 `pwd`（当前工作目录）和 `root`（根目录）都设置为该根目录 inode。
8.  **统计并打印空闲资源**：调用 `set_bit` 宏遍历位图，统计并打印空闲的数据块和 inode 数量。

此函数在 `init/main.c` 的 `main()` 函数中被调用，是内核从初始化到用户空间过渡的关键一步。

```mermaid
flowchart TD
A[系统启动] --> B[main.c: main()]
B --> C[main.c: time_init, tty_init, ...]
C --> D[main.c: buffer_init()]
D --> E[main.c: sti(), move_to_user_mode()]
E --> F[main.c: fork() -> init()]
F --> G[init.c: init()]
G --> H[init.c: setup()]
H --> I[fs/super.c: mount_root()]
I --> J[fs/super.c: do_mount(ROOT_DEV)]
J --> K[fs/super.c: bread(dev, 1)]
K --> L[fs/super.c: 魔数校验]
L --> M[fs/super.c: 读取 imap/zmap]
M --> N[fs/super.c: iget(ROOT_DEV, 1)]
N --> O[fs/super.c: 设置 current->root/pwd]
O --> P[init.c: execve(\"/bin/sh\", ...)]
```

**Diagram sources**
- [fs/super.c](file://fs/super.c#L69-L101)
- [init/main.c](file://init/main.c#L80-L85)
- [init/main.c](file://init/main.c#L120-L122)

**Section sources**
- [fs/super.c](file://fs/super.c#L69-L101)
- [init/main.c](file://init/main.c#L80-L85)

## 只读标志与系统控制

`s_rd_only` 是 `super_block` 结构体中的一个关键标志位，用于控制文件系统的写操作权限。
- 当 `s_rd_only` 为 0 时，文件系统处于可读写模式。
- 当 `s_rd_only` 为 1 时，文件系统被标记为只读，任何写操作都将被拒绝。

在 `do_mount()` 函数中，新挂载的文件系统会将其 `s_rd_only` 字段初始化为 0，允许写入。这个标志位为内核提供了一种全局的、针对特定文件系统的写保护机制，常用于系统维护或防止在关键设备（如根文件系统）上进行意外写入。

**Section sources**
- [include/linux/fs.h](file://include/linux/fs.h#L148)
- [fs/super.c](file://fs/super.c#L66)