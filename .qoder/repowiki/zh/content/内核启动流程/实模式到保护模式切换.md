# 实模式到保护模式切换

<cite>
**本文档引用的文件**  
- [boot.s](file://boot/boot.s)
- [head.s](file://boot/head.s)
- [segment.h](file://include/asm/segment.h)
- [head.h](file://include/linux/head.h)
</cite>

## 目录
1. [引言](#引言)
2. [实模式到保护模式的切换机制](#实模式到保护模式的切换机制)
3. [GDT与IDT的初始化](#gdt与idt的初始化)
4. [分页机制的建立](#分页机制的建立)
5. [总结](#总结)

## 引言
在x86架构的启动过程中，系统首先运行于16位实模式，随后必须切换至32位保护模式以启用现代操作系统所需的功能，如虚拟内存、分段保护和分页机制。本文详细阐述Linux 0.01内核中从实模式切换至保护模式的技术细节，重点分析`boot/boot.s`和`boot/head.s`中的关键代码流程。

## 实模式到保护模式的切换机制

在`boot/boot.s`中，系统完成加载内核至内存后，执行一系列关键操作以进入保护模式。首先，通过`cli`指令禁用中断，确保切换过程的原子性。随后，系统将加载的内核从0x10000地址移动至0x00000，为后续的保护模式运行准备内存布局。

接下来，通过`lidt`和`lgdt`指令加载中断描述符表（IDT）和全局描述符表（GDT）的初始结构。GDT中定义了两个核心段描述符：代码段（0x9A00）和数据段（0x9200），分别用于可执行代码和可读写数据，基地址为0，段限长为8MB，粒度为4KB。

为启用A20地址线，代码通过向8042键盘控制器发送命令，确保高地址访问正常，避免地址回绕问题。

最后，通过以下两条指令触发模式切换：
```asm
mov ax, #0x0001
lmsw ax
```
该操作设置控制寄存器CR0的PE（Protection Enable）位，激活保护模式。随后执行远跳转：
```asm
jmpi 0, 8
```
其中，`8`是代码段选择子，指向GDT中第二个描述符（索引为1，因GDT首项为空），即代码段。该远跳转刷新CS寄存器，并强制CPU进入32位操作模式。

**本节来源**  
- [boot.s](file://boot/boot.s#L150-L170)

## GDT与IDT的初始化

在`boot/head.s`中，系统在32位模式下重新初始化GDT和IDT。尽管在实模式下已加载GDT，但内核需在保护模式下使用自己的描述符表。

`setup_gdt`函数通过`lgdt`指令加载新的GDT描述符`gdt_descr`，其指向`_gdt`数组。该数组定义了四个关键项：
- 空描述符（索引0）
- 代码段描述符（0x00c09a00000007ff）：可执行、可读，限长8MB
- 数据段描述符（0x00c09200000007ff）：可读写，限长8MB
- 临时描述符（未使用）

类似地，`setup_idt`函数初始化IDT，将256个中断向量全部指向`ignore_int`处理程序，并设置为中断门（DPL=0，Present=1）。随后通过`lidt`指令加载IDT描述符。

初始化完成后，通过`movl $0x10, %eax`并重新加载DS、ES、FS、GS等段寄存器，选择子0x10对应GDT中的数据段（索引2），建立平坦内存模型，所有数据段基地址为0，实现线性地址空间的统一访问。

**本节来源**  
- [head.s](file://boot/head.s#L20-L60)
- [head.h](file://include/linux/head.h#L5-L15)

## 分页机制的建立

分页机制由`setup_paging`函数实现，其目标是启用虚拟内存，实现线性地址到物理地址的映射。该函数首先清零页目录（位于`_pg_dir`，即地址0x00000000），然后设置前两个页目录项：
- 第一项指向`pg0`（物理地址0x1000），权限为用户可读写且存在
- 第二项指向`pg1`（物理地址0x2000），同样设置为存在且可写

随后，函数将`pg1`的最后一页（4092字节偏移）开始，反向填充页表项，每个页表项映射4KB页面，权限为用户、可读写、存在，覆盖前8MB物理内存（0x00000000至0x00800000），实现恒等映射。

配置完成后，将页目录基址（0x00000000）写入CR3寄存器，再通过设置CR0寄存器的PG位（第31位）启用分页：
```asm
movl %cr0, %eax
orl $0x80000000, %eax
movl %eax, %cr0
```
此操作激活分页单元，此后所有内存访问均通过页表进行地址转换。

**本节来源**  
- [head.s](file://boot/head.s#L100-L150)

## 总结
Linux 0.01通过`boot.s`中的`lmsw`与远跳转实现从16位实模式到32位保护模式的切换，并在`head.s`中重新初始化GDT与IDT，建立平坦内存模型。通过设置页目录与页表，并启用CR0的PG位，系统成功启用分页机制，为后续内核运行提供虚拟内存支持。整个过程体现了早期操作系统对x86架构底层机制的精确控制。