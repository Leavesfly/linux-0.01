# 硬件中断（IRQ）处理流程

<cite>
**本文档中引用的文件**  
- [hd.c](file://kernel/hd.c)
- [serial.c](file://kernel/serial.c)
- [traps.c](file://kernel/traps.c)
- [io.h](file://include/asm/io.h)
</cite>

## 目录
1. [引言](#引言)
2. [中断处理总体流程](#中断处理总体流程)
3. [硬盘中断（IRQ14）处理路径](#硬盘中断irq14处理路径)
4. [串口（IRQ3/4）中断处理机制](#串口irq34中断处理机制)
5. [中断上下文限制与原子操作](#中断上下文限制与原子操作)
6. [中断结束信号（EOI）发送机制](#中断结束信号eoi发送机制)
7. [结论](#结论)

## 引言
本文深入解析 Linux 0.01 内核中外部硬件中断的完整处理路径。以硬盘驱动（IRQ14）和串口（IRQ3/4）为例，详细描述从中断发生、CPU 根据 IDT 跳转到汇编入口，执行现场保存，到调用 C 语言中断服务程序的全过程。分析中断处理程序如何与设备驱动交互，以及关键的中断控制机制。

## 中断处理总体流程
外部硬件中断由 8259A 可编程中断控制器（PIC）管理，CPU 通过中断描述符表（IDT）定位中断服务程序。中断处理分为汇编层和 C 语言层：汇编代码负责保存寄存器现场并跳转至 C 函数，C 函数执行具体设备处理逻辑，最后通过 `outb_p(0x20,0x20)` 发送 EOI 信号结束中断。

**Section sources**
- [traps.c](file://kernel/traps.c#L1-L200)

## 硬盘中断（IRQ14）处理路径
硬盘中断（IRQ14）在系统中映射为中断向量 0x2E。当硬盘操作完成时，硬件触发中断，CPU 根据 IDT 跳转至 `hd_interrupt` 汇编入口。该入口由 `set_trap_gate(0x2E, &hd_interrupt)` 在 `hd_init()` 中注册。

中断处理流程如下：
1. 汇编层保存 CPU 现场（寄存器状态）
2. 调用 C 语言函数 `hd_interrupt()`（由 `do_hd` 函数指针间接调用）
3. 根据当前请求类型（读/写），执行 `read_intr()` 或 `write_intr()`
4. 读取硬盘状态寄存器判断操作结果
5. 若成功，将数据从 I/O 端口读入缓冲区（`port_read`），标记缓冲区为最新（`b_uptodate = 1`），唤醒等待进程
6. 若失败，执行错误处理（`bad_rw_intr()`），重试或放弃请求
7. 调用 `do_request()` 处理下一个请求

**Section sources**
- [hd.c](file://kernel/hd.c#L0-L414)

## 串口（IRQ3/4）中断处理机制
串口使用 IRQ3（COM2）和 IRQ4（COM1），分别映射为中断向量 0x23 和 0x24。`rs_init()` 函数通过 `set_intr_gate()` 注册 `rs1_interrupt` 和 `rs2_interrupt` 作为中断处理入口。

串口处理机制包括：
- **接收中断**：当串口接收到数据时，触发中断，内核从数据端口读取字符并放入 `read_q` 队列，调用 `copy_to_cooked()` 进行预处理。
- **发送中断**：当串口准备好发送下一个字符时，触发中断。`rs_write()` 函数在发送队列非空时启用发送中断，中断发生后从 `write_q` 取出字符发送，并在队列变空时关闭中断。

串口初始化通过 `init()` 函数配置波特率、数据位、停止位和中断使能。

**Section sources**
- [serial.c](file://kernel/serial.c#L0-L54)

## 中断上下文限制与原子操作
中断处理运行在中断上下文中，具有以下关键限制：
- **不可睡眠**：中断处理程序不能调用可能引起进程调度的函数（如 `sleep_on`），因为中断上下文不关联任何进程。
- **不可阻塞**：所有操作必须快速完成，避免长时间占用 CPU。

为保证关键代码段的原子性，内核使用 `cli()`（关中断）和 `sti()`（开中断）指令。例如，在 `rs_write()` 中，修改串口控制寄存器前调用 `cli()`，防止中断嵌套导致状态不一致。

**Section sources**
- [serial.c](file://kernel/serial.c#L45-L50)
- [hd.c](file://kernel/hd.c#L350-L355)

## 中断结束信号（EOI）发送机制
8259A PIC 要求在中断处理完成后发送中断结束（EOI）信号，以通知控制器可以接受下一个中断。在 Linux 0.01 中，EOI 通过向主 PIC 的 I/O 端口 0x20 写入值 0x20 实现：

```c
outb_p(0x20, 0x20);
```

其中 `outb_p` 是带延时的端口输出函数，确保写操作被硬件正确接收。该操作通常在中断处理程序末尾执行，确保中断服务完全完成后再通知 PIC。

**Section sources**
- [hd.c](file://kernel/hd.c#L410-L412)
- [io.h](file://include/asm/io.h#L10-L13)

## 结论
Linux 0.01 的硬件中断处理机制体现了简洁而高效的中断处理设计。通过汇编与 C 语言的协作，实现了从硬件中断到设备驱动的无缝衔接。硬盘和串口的中断处理展示了典型的设备驱动交互模式：状态查询、数据传输、错误处理和资源唤醒。中断上下文的限制和 `cli`/`sti` 的使用确保了系统的稳定性和原子性。EOI 信号的正确发送是中断系统可靠运行的关键环节。