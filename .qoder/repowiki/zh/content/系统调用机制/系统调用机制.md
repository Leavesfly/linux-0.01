# 系统调用机制

<cite>
**本文档中引用的文件**  
- [unistd.h](file://include/unistd.h)
- [linux/sys.h](file://include/linux/sys.h)
- [traps.c](file://kernel/traps.c)
- [sys.c](file://kernel/sys.c)
- [asm/system.h](file://include/asm/system.h)
- [lib/open.c](file://lib/open.c)
- [lib/write.c](file://lib/write.c)
- [lib/close.c](file://lib/close.c)
- [lib/dup.c](file://lib/dup.c)
- [lib/setsid.c](file://lib/setsid.c)
- [sys/stat.h](file://include/sys/stat.h)
</cite>

## 目录
1. [引言](#引言)
2. [系统调用号定义](#系统调用号定义)
3. [系统调用函数指针表](#系统调用函数指针表)
4. [系统调用入口点流程](#系统调用入口点流程)
5. [具体系统调用实现模式](#具体系统调用实现模式)
6. [用户态触发与封装函数生成](#用户态触发与封装函数生成)
7. [系统调用参数传递与错误处理](#系统调用参数传递与错误处理)
8. [自定义系统调用添加示例](#自定义系统调用添加示例)

## 引言
系统调用是用户程序与操作系统内核之间进行交互的核心机制。通过系统调用，用户程序可以请求内核执行特权操作，如文件读写、进程控制、内存管理等。本文档深入分析 Linux 0.01 内核中的系统调用机制，涵盖从用户态触发到内核处理的完整流程，并提供扩展自定义系统调用的方法。

## 系统调用号定义
系统调用号用于唯一标识每个系统调用，在用户态和内核态之间建立映射关系。这些编号在头文件 `include/unistd.h` 中定义，以 `__NR_` 为前缀。

例如：
- `__NR_open` 表示 `open` 系统调用
- `__NR_read` 表示 `read` 系统调用
- `__NR_write` 表示 `write` 系统调用

这些宏定义仅在 `__LIBRARY__` 宏被定义时生效，通常出现在库函数实现中（如 `lib/` 目录下的文件），确保调用号在用户空间正确使用。

**本节来源**  
- [unistd.h](file://include/unistd.h#L35-L80)

## 系统调用函数指针表
内核通过一个函数指针数组 `sys_call_table` 来管理所有系统调用的实现函数。该表定义于 `include/linux/sys.h` 文件中，其元素顺序与系统调用号一一对应。

例如：
```c
fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, ... };
```

当用户程序发起系统调用时，内核根据 `eax` 寄存器中的调用号作为索引，从 `sys_call_table` 中查找并调用对应的处理函数。

**本节来源**  
- [linux/sys.h](file://include/linux/sys.h#L78-L80)

## 系统调用入口点流程
系统调用的入口点由汇编代码实现，位于 `kernel/traps.c` 中的中断向量表设置部分。用户程序通过执行 `int 0x80` 指令触发软中断，进入内核态。

工作流程如下：
1. **保存寄存器状态**：CPU 自动压入 `EIP`、`CS`、`EFLAGS` 等寄存器。
2. **切换到内核栈**：使用内核的堆栈进行后续操作。
3. **检查系统调用号有效性**：确保 `eax` 中的调用号在合法范围内。
4. **调用对应函数**：通过 `sys_call_table[eax]` 调用实际的系统调用处理函数。
5. **处理返回值和信号**：将结果写回 `eax`，并在返回用户态前检查是否有待处理的信号。

尽管 `traps.c` 主要用于异常处理（如除零、页错误），但其通过 `set_system_gate(0x80, &system_call)` 设置了系统调用的中断门，允许用户态调用。

**本节来源**  
- [traps.c](file://kernel/traps.c#L150-L199)
- [asm/system.h](file://include/asm/system.h#L30-L32)

## 具体系统调用实现模式
具体的系统调用实现在 `kernel/sys.c` 文件中，每个函数以 `sys_` 为前缀，例如 `sys_open`、`sys_read`、`sys_write` 等。

分析 `sys_setsid` 的实现模式：
- 函数首先检查调用进程是否有权限执行该操作（如是否为 root 用户）。
- 若权限不足，返回负的错误码（如 `-EPERM`）。
- 成功则修改进程属性（如会话 ID、进程组 ID），并返回新值。

其他系统调用遵循类似模式：参数验证 → 权限检查 → 执行操作 → 返回结果或错误码。

**本节来源**  
- [sys.c](file://kernel/sys.c#L180-L216)
- [sys.c](file://kernel/sys.c#L100-L110)

## 用户态触发与封装函数生成
用户程序通过 `int 0x80` 指令触发系统调用。为了简化调用过程，内核提供 `_syscallN()` 宏来自动生成封装函数，其中 `N` 表示参数个数（0~3）。

例如，在 `lib/open.c` 中：
```c
#define __LIBRARY__
#include <unistd.h>

int open(const char * filename, int flag, ...)
{
	register int res;
	va_list arg;

	va_start(arg,flag);
	__asm__("int $0x80"
		:"=a" (res)
		:"0" (__NR_open),"b" (filename),"c" (flag),
		"d" (va_arg(arg,int)));
	if (res>=0)
		return res;
	errno = -res;
	return -1;
}
```

而更简洁的方式是使用宏定义，如 `lib/write.c` 所示：
```c
_syscall3(int,write,int,fd,const char *,buf,off_t,count)
```
该宏展开后自动生成带有三参数的 `write` 封装函数，通过 `ebx`、`ecx`、`edx` 传递参数，`eax` 返回结果。

**本节来源**  
- [lib/open.c](file://lib/open.c#L5-L19)
- [lib/write.c](file://lib/write.c#L3)
- [unistd.h](file://include/unistd.h#L190-L247)

## 系统调用参数传递与错误处理
### 参数传递方式
系统调用参数通过 CPU 寄存器传递：
- 系统调用号：`eax`
- 第一个参数：`ebx`
- 第二个参数：`ecx`
- 第三个参数：`edx`
- 第四个参数（若有）：需通过栈传递（本版本最多支持三个参数）

这种设计避免了频繁的栈操作，提高调用效率。

### 错误处理机制
系统调用成功时返回非负值（如文件描述符、字节数）；失败时返回负的错误码（如 `-EINVAL`、`-EPERM`）。封装函数检测到返回值小于 0 时，将其取反赋给全局变量 `errno`，并返回 `-1`。

例如：
```c
if (__res >= 0)
	return __res;
errno = -__res;
return -1;
```

错误码定义在 `include/errno.h` 中，如 `EPERM=1`、`ENOENT=2` 等。

**本节来源**  
- [unistd.h](file://include/unistd.h#L190-L247)
- [lib/close.c](file://lib/close.c#L4)
- [lib/dup.c](file://lib/dup.c#L4)

## 自定义系统调用添加示例
要添加一个自定义系统调用（如 `sys_hello`），需执行以下步骤：

1. **定义系统调用号**  
   在 `include/unistd.h` 中添加：
   ```c
   #define __NR_hello 67
   ```

2. **声明函数原型**  
   在 `include/linux/sys.h` 中添加：
   ```c
   extern int sys_hello(void);
   ```

3. **实现系统调用函数**  
   在 `kernel/sys.c` 中添加：
   ```c
   int sys_hello(void)
   {
       printk("Hello from kernel!\n");
       return 0;
   }
   ```

4. **更新系统调用表**  
   在 `sys_call_table` 数组末尾添加 `sys_hello`。

5. **编写用户态调用程序**  
   使用 `_syscall0(int, hello)` 宏生成封装函数并调用。

完成上述步骤后，重新编译内核即可使用新的系统调用。

**本节来源**  
- [unistd.h](file://include/unistd.h#L35-L80)
- [linux/sys.h](file://include/linux/sys.h#L78)
- [sys.c](file://kernel/sys.c#L180-L216)
- [unistd.h](file://include/unistd.h#L190-L193)